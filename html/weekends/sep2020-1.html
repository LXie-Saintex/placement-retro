<html>
    <head>
        <title>September weekon: Makers ER app</title>
        <link rel="stylesheet" href="../../css/basic.css">
    </head>
    <body>
        <li class="date">25th Sep - 27th Sep, 2020</li>
        <article>
            <p>See description at README: <a href="https://github.com/lxierita/makers-employer-reference">https://github.com/lxierita/makers-employer-reference</a></p>
            <p>See notes at: <a href="../notes.html#mer">Notes on the MER app</a></p>
            <p>Plan</p>
            <ol>
                <li>
                    <h2>25th Sep night</h2>
                    <p>What: 
                        <ul>
                            <li>‚úÖ Determines which AWS resources to use, how cloud-native this app will be:
                                <ul>
                                    <li>AWS Amplify Console: hosting</li>
                                    <li>AWS API Gateway & AWS Lambda: business logic</li>
                                    <li>AWS DynamoDB: storage</li>
                                </ul>
                            </li>
                            <li>‚úÖ Determines if use K8s: Not Needed</li>
                            <li>‚úÖ Determines if use Terraform: Not Needed</li>
                            <li>‚úÖ Determines if use AWS Lambda: Yes</li>
                        </ul>
                    </p>
                    <p>How: 
                        <ul>
                            <li>Book: AWS Certified Solutions Architect Official Study Guide</li>
                            <li>Sites: <a href="https://docs.aws.amazon.com/index.html">https://docs.aws.amazon.com/index.html</a></li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h2>26th Sep</h2>
                    <p>What: Complete frontend MVP
                        <ul>
                            <li>‚ùåUser can log in to see the app</li>
                            <li>‚ùåUI has a navigation menu</li>
                            <li>‚ùåThe menus lists 18 standard pts</li>
                            <li>‚úÖEach pt section has evidence</li>
                            <li>‚ùåUser can comment on each pt section, <b>NOT</b> on each evidence</li>
                            <li>‚ùåUser can delete own comments</li>
                            <li>‚ùåUser can see the author of the comments</li>
                            <li>‚úÖEach evidence contains screenshots</li>
                            <li>‚úÖEach screenshot contains description</li>
                        </ul>
                    </p>
                    <p>How: 
                        <ul>
                            <li>Site: Elm</li>
                            <li>Repos: past projects</li>
                        </ul>
                    </p>
                    <p>üåöWell, theoretically, everything in the list has been implemented, but there is no backend to test. 
                        I can see the Login page fine, but can't see others because the decoder is not implemented. And it's not
                        implemented because there is no example http response. it's a waste of time to guess what the backend should look like 
                        and write the decoders and change later. I had fun, but the flow is still a bit fucked up. But the work was good for 1 day I'd say. üåù
                    </p>
                </li>
                <li>
                    <h2>27th Sep</h2>
                    <p>What: Store in and Deploy to cloud
                        <ul>
                            <li>‚ùå can retrieve comments from storage</li>
                            <li>‚ùå can create and store new comments</li>
                            <li>‚ùå can authenticate the user</li>
                            <li>‚ùå app accessible via Internet: e.g. can log in and view the evidence and comment</li>
                        </ul>
                    </p>
                    <p>What v2: cloud-native backend
                        <ul>
                            <li>Elm app hosted on Amplify</li>
                            <li>‚û°Ô∏è CirlceCI configured to use aws resources</li>
                            <li>‚úÖ RestAPI spec written in Swagger</li>
                            <li>
                                <p>Lambdas hosted on AWS</p>
                                <ul>
                                    <li>‚û°Ô∏èAuthenticate</li>
                                    <li>Retrieve</li>
                                    <li>Add</li>
                                    <li>Delete</li>
                                </ul>
                            </li> 
                            <li>Integrate proxy requests Lambdas with API Gateway</li>
                            <li>DynamoDB table that has 18 items</li>
                            <li>images stored in S3</li>
                        </ul>
                    </p>
                    <p>How: 
                        <ul>
                            <li>AWS SDK for Go</li>
                            <li>AWS lambda</li>
                            <li>one of the AWS storage services</li>
                        </ul>
                    </p>
                </li>
            </ol>
        </article>
        <article>
            <h2>Summary</h2>
            <p>
                The most important things I've learnt are: 
            </p>
            <p>
                <b>1. adopt an API-first approach or use Elm: </b> writing the doc in Swagger really gave me a clear picture of the business logic of the app. 
                It's better than guessing from the frontend as see fit. Luckily, the Elm architecture helped alleviate the pain. I kept thinking
                about Evan's talk on The life of a file as the data structure does evolve and unfold itself in front of me as I go on along. so 
                even without doing the API first, I did pretty well in envisioning what the backend would look like. <br>
                Next time, I'd use API-first if I'm familiar with the backend technologies, otherwise I'll use Elm to get something up and running at the front.
            </p>
            <p>
                <b>2. make notes of the questions and doubts along the way:</b> It smooths out my thought process; by forcing myself to put it into words, 
                I was working to find out what the actual questions are, how many are they. It allows me to learn about how I learn; by reflecting on the notes, 
                say after a while, I should discover what kind of questions do I ask and hence how do I approach a problem and translate it to myself. It also 
                helps measuring my learning ability over time; was I able to divide and conquer? could I surface the problem when the program deficiency is not obviosu; 
                One last benefit is that I get to teach someone better than the docs once realised the common pitfalls.
            </p>
            <p>
                In general, I'm quite happy about this project even though it's still a failure as the ‚ùås still there. This time, the goals are more acheivable and specific. 
                I was more devoted and entertained by it as the items are more actionable. The backend part gave very dubious goals and descriptions due to the alienness of
                of the concepts, still I felt that I made great progress because I refined them with the help of the notes. I'll continue working on it the weekend after, so meanwhile
                had to use a text document to collect the evidence and commentaries. 
            </p>
        </article>
    </body>
</html>